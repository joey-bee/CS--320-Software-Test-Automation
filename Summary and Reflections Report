
Project 2: Summary and Reflections Report


Joseph M Opheim
CS 320: Software Test, Automation
Southern New Hamshire University
Dr. Robert Nardelli
February 21, 2026
 
Unit Testing for Mobile Application Development
This report outlines a summary of my unit testing strategy to the mobile application that was created on Project One to serve Grand Strand Systems. This project entailed the development of three backend services namely; Contact Service, Task Service, and Appointment Service. JUnit tests were done on each service to ensure that it fulfilled all requirements.
Summary of Unit Testing Approach
Unit Testing Approach
The unit testing of all three features had a similar methodology that was in line with the software requirements. In the case of the Contact class, the testContactIDTooLong method of line 24 of ContactTest.java confirms that contact IDs exceeding 10 characters cause an exception of an IllegalArgumentException. On line 66 there is the testPhoneNotTenDigits method, which makes sure that the phone numbers have to contain exactly 10 digits. This was in direct agreement with the requirement that the phone field should be precisely 10 digits with no null. In case with Task Service, the testInvalidTaskId method checks the null task IDs as well as those that are over 10 characters. On line 39, the testNameBoundary method, develops a task whose name is 20 characters in length which is the exact boundary to test the reality of a true boundary. In the case of Appointment Service, the testAppointmentDateNotInPast method uses the new Date(0) to construct a past date which is rejected by the constructor as it is required that appointmentDate must not be in the past. My JUnit tests were of high quality and all three services had more than 80 percent code coverage. I created 79 unit tests in all, including normal operation, boundary, and error case testing. ContactTest class has 16 tests, TaskTest has 13 tests and AppointmentTest has 13 tests. This broad coverage will assure that every approach and code path is tested.
Test Writing Experience
To make sure that my code was technically sound, I applied rigorous validation tests in all my tests. ContactServiceTest.java is built on the principle of creating two contacts with the same ID in the testAddContactWithDuplicateID on lines 20-28; on the next 20 lines the test method will generate an IllegalArgException by asserting that the second contact is created, such an exception is expected to be thrown in the test method. The line 48 testDeleteWithNullID method will ensure the delete method, which is passed null, does not throw a null pointer exception but instead returns false. Test design was carefully done to ensure efficiency. In TaskServiceTest.java, both the name and description updates in one test are proved in the testUpdateMultipleFields method of the 118 to 124 lines instead of making individual tests. The setUp method in ContactServiceTest.java between lines 7 and 10 initializes the service once, which eradicates the repeated code of initiation and speed up the tests.
Reflection on Testing Techniques
The main testing method that I used was unit testing with the JUnit framework. Unit testing is performed to test the functionality of single parts independently as an isolation test (Lukasczyk et al., 2023). In this project, I tested the classes and the methods separately. The advantages of unit testing are fast execution, lack of external dependencies, and real-time feedback on the correctness of the code. I also used the testing of boundaries, which analyzes the behavior at the limits of the input domains. The tasktest.java method of testDescriptionBoundary is used to generate a description of 50 characters to ensure that the system accepts the maximum length of valid input.
Other testing methods that I never applied are integration testing and system testing. Integration testing is used to make sure that various parts do not interfere with one another when put together (Hellhake et al., 2022). As an illustration, the integration testing would assure that the Contact Service communicates with a database as expected in case of such dependencies. System testing analyzes the complete application as well as user interfaces and end-to-end workflows. This would include testing the interaction between the users in the mobile application interface to add and manage contacts, tasks, and appointments.
Unit testing is the most feasible when it comes to testing the functionality of individual components during the development process, and as such, enables the developers to identify bugs promptly. Integration testing is also significant when several services have to interact with each other, like the communication between the backend services and the databases or third-party APIs. Testing before deployment is necessary to test all components in the system and to test them in real-world situations as per the specifications of the user.
Reflection on Mindset
As a software tester, I needed to be very careful and attentive. I thoroughly read all the validation requirements and developed tests of both valid and invalid inputs. In the case of phone number validation in the Contact class, I used different tests on null values, wrong length and non-numeric characters. This comprehensiveness was required since the absence of any validation scenario would permit unreliable data into the system, which will lead to failure in the application or security breaches. It was important to appreciate the complexity of codes and their interrelationship. ContactService class is a subclass of HashMap that stores contacts and there are several methods that deal with it. There was a need to restrain bias consciously during testing. I specifically designed tests that put my assumptions concerning the behavior of the code to test. When testing the updateFirstName method, I tested successful and unsuccessful updates as well as testing updating non-existing contacts. Evaluating my own code was not an easy task since I was aware of the implementation particulars and may unconsciously not test a bad area. To fight this, I adhered to the requirements document to the letter and developed tests that were made on specifications as opposed to knowing how to implement it.
Software engineering requires discipline and dedication to quality. Cutting corners reduces testing produces technical debt, a hypothetical cost of reworking in the future due to selecting quick and easy solutions instead of the more desirable ones (Ahmad et al., 2025). Omitting edge case testing could even make it to production and necessitate emergency software repair and user confidence. To avert technical debt as a practitioner, I will ensure that I write detailed tests in early development, perform regular code reviews, and refactoring as a proactive response in case some code becomes hard to maintain.
Conclusion
The given project strengthened the role of the systematic testing and development oriented on the quality. By unit testing the Contact, Task, and Appointment services fully, I was able to practice the ability to develop useful test cases, code quality maintenance. My disciplined testing attitude was also something I embraced that will be the basis of my further development as a software engineering expert. On the whole, It has been an excellent learning experience.
 
References
Ahmad, M. O., Al-Baik, O., Hussein, A., & Abu-Alhaija, M. (2025). Unraveling the organisational debt phenomenon in software companies. Computer Science and Information Systems, 22(1), 369-399. https://doi.org/10.2298/CSIS240411012A
Hellhake, D., Bogner, J., Schmid, T., & Wagner, S. (2022). Towards using coupling measures to guide black‐box integration testing in component‐based systems. Software Testing, Verification and Reliability, 32(4), e1811. https://onlinelibrary.wiley.com/doi/abs/10.1002/stvr.1811
Lukasczyk, S., Kroiß, F., & Fraser, G. (2023). An empirical study of automated unit test generation for Python. Empirical Software Engineering, 28(2), 36. https://link.springer.com/article/10.1007/s10664-022-10248-w

